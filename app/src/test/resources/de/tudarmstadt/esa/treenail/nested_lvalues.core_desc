InstructionSet NestedLValues {
  architectural_state {
    register unsigned<32> X[32] [[is_main_reg]];
    register unsigned<32> PC;
    extern unsigned char MEM[0x100000000] [[is_main_mem]];
  }

  instructions {
    SimpleRegStore {
       encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
       behavior: {
         X[rs2] = 43;
       }
    }
    SimpleBitAccessStore {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        PC[4:0] = 3;
      }
    }
    SimpleRangedAddressSpaceStore {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        MEM[4:0] = MEM[8:4];
      }
    }
    RegScalarThenBitAccessStore {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        X[rs2][0:10] = 100;
      }
    }
    MemScalarThenBitAccessStore {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        MEM[rs2][0:4] = 8;
      }
    }
    NestedBitAccess {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        PC[16:0][8:0] = 42;
      }
    }
    TripleNestedBitAccess {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        PC[31:0][15:0][7:0] = 42;
      }
    }
    // TODO: need to test:
    // - Every following option needs to be tested with locals and non-locals
    // - ranged bit access then bit access
    // - ranged address space access then element access
    // - ranged address space access then bit access
    // - ranged address space access then element access then bit access
    // - element access then bit access
  }
}
