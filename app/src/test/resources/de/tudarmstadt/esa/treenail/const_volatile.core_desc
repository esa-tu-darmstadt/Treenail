InstructionSet TestConstVolatile {
    architectural_state {
      unsigned int XLEN = 32;
      unsigned int RFS = 32;
      // Register files with qualifiers
      register unsigned<XLEN> X[RFS] [[is_main_reg]];
      register const unsigned<XLEN> CONST_REG_FILE[10];
      register volatile unsigned<XLEN> VOLATILE_REG_FILE[12];
      register const volatile unsigned<XLEN> CONST_VOLATILE_REG_FILE[14];

      // Scalar registers with qualifiers
      register unsigned<XLEN> NORMAL_REG = 5;
      register const unsigned<XLEN> CONST_REG = 10;
      register volatile unsigned<XLEN> VOLATILE_REG = 12;
      register const volatile unsigned<XLEN> CONST_VOLATILE_REG = 42;

      extern unsigned<8> MEM[1 << XLEN] [[is_main_mem]];
      extern const unsigned<8> CONST_MEM[1 << 64] [[is_main_mem]];
      // It probably does not make sense for multiple address spaces to
      // be marked "is_main_mem"
      // TODO: remove [[is_main_mem]] when custom address spaces are supported
      extern volatile unsigned<8> VOLATILE_MEM[1 << 8] [[is_main_mem]];
      extern const volatile unsigned<8> CONST_VOLATILE_MEM[1 << 16] [[is_main_mem]];

      // const and volatile aliases
      unsigned<8> &FIRST_MEM_VAL = MEM[0];
      const unsigned<8> &FIRST_CONST_MEM_VAL = CONST_MEM[0];
      volatile unsigned<8> &FIRST_VOLATILE_MEM_VAL = VOLATILE_MEM[0];
      const volatile unsigned<8> &FIRST_CONST_VOLATILE_MEM_VAL = CONST_VOLATILE_MEM[0];
    }

  instructions {
    Inst1 {
        encoding: 5'b00000 :: 1'b0 :: Imm6[0:5] :: rs1[4:3] :: rs1[0:2] :: 3'b110 :: rd[4:0] :: 7'b1111011;
        behavior: {
          unsigned<32> x = MEM[Imm6];
          X[rd] = x;
        }
    }
  }
}
