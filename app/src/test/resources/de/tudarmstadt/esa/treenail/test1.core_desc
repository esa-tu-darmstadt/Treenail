InstructionSet Test1 {
  architectural_state {
    register unsigned<32> X[32] [[is_main_reg]];
    register unsigned<17> Y;
    unsigned<32> XLEN = 32;
    unsigned<32> XLEN_2 = XLEN/2;
    unsigned<32> XLEN_4 = XLEN/4;
    extern unsigned char MEM[1048576] [[is_main_mem]];
    extern unsigned int CSR[4096];
  }

  instructions {
    Inst1 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<32> x = imm;
        unsigned<32> y = Y;
        X[rd] = x;
        X[rd] = y;
      }
    }

    Inst2 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        X[rd] = (unsigned) (imm + 42 - 1 * 3 / 7 % 15);
        signed<100> xxx = imm & 20'hFFFFF | 0 ^ 20'hCCCCC << 5 >> 17;
        X[rd] = (unsigned<32>) (xxx + 1);
      }
    }

    Inst3 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        X[rd] = imm > 0 | (unsigned)(-imm) | !imm | ~imm;
      }
    }

    Inst4 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<3> idx = 1;
        X[rd] = imm[2] + imm[idx];
        X[rd] = X[imm[5:1]];
        idx[0] = 1;
        idx[0:1] = 2'b11;
        Y[7] = imm[7];
        Y[16:4] = 3'd5;
      }
    }

    Inst5 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        signed<100> xxx = imm;
        X[rd] = (unsigned<32>) (xxx :: 1 :: imm :: -1);
      }
    }

    Inst6 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<10> x = 3;
        signed<5> y = -4;
        if (imm > 0)
          x = 42;
        else
          y = (signed<5>)(y * 5);
        X[rd] = x;
        if (imm < 100)
          Y = x;
        else
          Y = (unsigned) y;
      }
    }

    Inst7 {
      encoding: 0b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        signed<XLEN_4> op1_0 = (signed) X[rs1][ 7: 0];
        signed<XLEN_4> op1_1 = (signed) X[rs1][15: 8];
        signed<XLEN_4> op2_0 = (signed) X[rs2][ 7: 0];
        signed<XLEN_4> op2_1 = (signed) X[rs2][15: 8];
        signed<XLEN> op3 = (signed) X[rd];
        signed<XLEN_2> mul0 = op1_0 * op2_0;
        signed<XLEN_2> mul1 = op1_1 * op2_1;
        signed<17> sum_tmp = mul0 + mul1;
        signed<33> result = op3 + sum_tmp;
        if(rd != 0) X[rd] = result[31:0];
      }
    }

    Inst8 {
      encoding: imm[6:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        MEM[imm] = 0xFF;
        MEM[X[rs1]] = MEM[imm];
        MEM[11:8] = 0xC0FFEE;
        unsigned<3> smallIdx = imm[5:3];
        MEM[imm+3:imm] = MEM[imm:imm+2];
        unsigned<11> x = 0;
        x[smallIdx:smallIdx+5] = x[smallIdx+4:smallIdx];
      }
    }

    Inst9 {
      encoding: imm[6:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        X[rd] = (unsigned)(rs1 > 4 && rs2 < 2 ? -imm : imm[0:3]);
      }
    }
  }
}

