InstructionSet Test1 {
  architectural_state {
    register unsigned<32> X[32] [[is_main_reg]];
    register unsigned<17> Y;
    register signed<5> Z[4];
    unsigned<32> XLEN = 32;
    unsigned<32> XLEN_2 = XLEN/2;
    unsigned<32> XLEN_4 = XLEN/4;
    extern unsigned char MEM[1048576] [[is_main_mem]];
    extern unsigned int CSR[4096];
    const register unsigned<4> FOO = 1+1;
  }

  instructions {
    Inst1 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<32> x = imm;
        unsigned<32> y = Y;
        X[rd] = x;
        X[rd] = y;
      }
    }

    Inst2 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        X[rd] = (unsigned) (imm + 42 - 1 * 3 / 7 % 15);
        signed<100> xxx = imm & 20'hFFFFF | 0 ^ 20'hCCCCC << 5 >> 17;
        X[rd] = (unsigned<32>) (xxx + 1);
      }
    }

    Inst3 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        X[rd] = imm > 0 | (unsigned)(-imm) | !imm | ~imm;
      }
    }

    Inst4 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<3> idx = 1;
        X[rd] = imm[2] + imm[idx];
        X[rd] = X[imm[5:1]];
        idx[0] = 1;
        idx[0:1] = 2'b11;
        Y[7] = imm[7];
        Y[16:4] = 3'd5;
      }
    }

    Inst5 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        signed<100> xxx = imm;
        X[rd] = (unsigned<32>) (xxx :: 1 :: imm :: -1);
      }
    }

    Inst6 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<10> x = 3;
        signed<5> y = -4;
        if (imm > 0)
          x = 42;
        else
          y = (signed<5>)(y * 5);
        X[rd] = x;
        if (imm < 100)
          Y = x;
        else
          Y = (unsigned) y;
      }
    }

    Inst7 {
      encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        signed<XLEN_4> op1_0 = (signed) X[rs1][ 7: 0];
        signed<XLEN_4> op1_1 = (signed) X[rs1][15: 8];
        signed<XLEN_4> op2_0 = (signed) X[rs2][ 7: 0];
        signed<XLEN_4> op2_1 = (signed) X[rs2][15: 8];
        signed<XLEN> op3 = (signed) X[rd];
        signed<XLEN_2> mul0 = op1_0 * op2_0;
        signed<XLEN_2> mul1 = op1_1 * op2_1;
        signed<17> sum_tmp = mul0 + mul1;
        signed<33> result = op3 + sum_tmp;
        if(rd != 0) X[rd] = result[31:0];
      }
    }

    Inst8 {
      encoding: imm[6:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        MEM[imm] = 0xFF;
        MEM[X[rs1]] = MEM[imm];
        MEM[11:8] = 0xC0FFEE;
        unsigned<3> smallIdx = imm[5:3];
        MEM[imm+3:imm] = MEM[imm:imm+2];
        unsigned<11> x = 0;
        x[smallIdx:smallIdx+5] = x[smallIdx+4:smallIdx];
      }
    }

    Inst9 {
      encoding: imm[6:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0101011;
      behavior: {
        X[rd] = (unsigned)(rs1 > 4 && rs2 < 2 ? -imm : imm[0:3]);
      }
    }

    Inst10 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<32> x = 0;
        x &= imm;
        x |= imm;
        x ^= imm;
        x <<= imm;
        x >>= imm;
        x += imm;
        x -= imm;
        x *= imm;
        x /= imm;
        x %= imm;
        X[rd] = x;

        Z[3] &= 1;
        Z[3] |= 2;
        Z[3] ^= 3;
        Z[3] <<= 4;
        Z[3] >>= 5;
        Z[3] += 6;
        Z[3] -= 7;
        Z[3] *= 8;
        Z[3] /= 9;
        Z[3] %= 10;
      }
    }

    Inst11 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<32> x = 0;
        ++x;
        --x;
        x++;
        x--;
        X[rd] = (x--) | x | (--x);
        X[rd]++;
        --Y;
      }
    }

    Inst12 {
      encoding: imm[19:0] :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<17> x = 0;
        signed<5> z = -3;
        for (unsigned<4> i = 0; i < 5; ++i) {
          x += i;
          z -= i;
        }
        X[rd] = x;
        Z[1] = z;

        for (unsigned<4> i = 0; i < imm; i <<= 2) {
          x += i;
          z -= i;
        }

        X[rd] = x;
        Z[2] = z;
      }
    }

    Inst13 {
      encoding: 7'd0 :: rs2[4:0] :: rs1[4:0] :: 3'd0 :: rd[4:0] :: 7'b0000010;
      behavior: {
        unsigned<32> arg1 = X[rs1];
        unsigned<32> arg2 = X[rs2];
        unsigned<32> res = 0;
        for (unsigned<5> i = 0; i < 4; ++i) {
          unsigned<5> base = i << 3;
          res[base+7:base] = (arg1[base+7:base] * arg2[base+7:base])[7:0];
        }
        X[rd] = res;
      }
    }

    REV8 {
      encoding: 12'b011010011000 :: rs[4:0] :: 3'b101 :: rd[4:0] :: 7'b0010011;
      behavior: {
        unsigned int arg1 = X[rs], res = 0;
        int j = 24;
        for (int i = 0; i < 32; i += 8) {
          res[i+7 : i] = arg1[j+7 : j];
          j -= 8;
        }
        X[rd] = res;
      }
    }

    DOTP {
      encoding: 7'd0 :: rs2[4:0] :: rs1[4:0] :: 3'd0 :: rd[4:0] :: 7'b0001011;
      behavior: {
        signed<32> res = 0;
        for (int i = 0; i < 32; i += 8) {
          signed<16> prod = (signed) X[rs1][i+7:i] * (signed) X[rs2][i+7:i];
          res += prod;
        }
        X[rd] = (unsigned) res;
      }
    }

    CALL {
      encoding: 7'd0 :: rs2[4:0] :: rs1[4:0] :: 3'd0 :: rd[4:0] :: 7'b0001011;
      behavior: {
        X[rd] = foo(X[rs1], X[rs2]);
      }
    }
  }

  functions {
    unsigned<32> sideeffect() {
      Y = 0;
      return 0;
    }

    unsigned<32> foo(unsigned<32> a, unsigned<32> b) {
      sideeffect();
      return (a + b)[31:0];
    }
  }
}

