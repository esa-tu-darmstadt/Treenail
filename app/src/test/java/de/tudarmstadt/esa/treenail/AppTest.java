/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.tudarmstadt.esa.treenail;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class AppTest {
  @Test
  void parserWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("intro_syntax.core_desc").getPath();
    assertNotNull(appInst.parse(fileName),
                  "app should be able to parse a simple CoreDSL file");
  }

  @Test
  void codegenWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("test1.core_desc").getPath();
    var content = appInst.parse(fileName);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(
        appInst.generateMLIR(content).startsWith("coredsl.isax \"Test1\""),
        "app should be able to generate MLIR");
  }

  @Test
  void splitEncodingFieldWorks() {
    var appInst = App.getInstance();
    var fileName =
        getClass().getResource("split_enc_field.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(mlirCode.startsWith("coredsl.isax \"TestSplitEncFields\""),
               "app should be able to generate MLIR");
    assertTrue(mlirCode.contains("%TREENAIL_WAS_HERE_0 = coredsl.concat "
                                 + "%TREENAIL_WAS_HERE_Imm6_5_1, "
                                 + "%TREENAIL_WAS_HERE_Imm6_0_0 : ui5, ui1"),
               "app should be able to merge split encoding fields");
    assertTrue(
        mlirCode.contains(
            "%Imm6 = coredsl.cast %TREENAIL_WAS_HERE_0 : ui6 to ui6"),
        "app should be able to retain the original split encoding field name");
  }

  @Test
  void reversedEncodingFieldWorks() {
    var appInst = App.getInstance();
    var fileName =
        getClass().getResource("reversed_enc_field.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(mlirCode.startsWith("coredsl.isax \"TestReversedEncFields\""),
               "app should be able to generate MLIR");
    assertTrue(
        mlirCode.contains("%TREENAIL_WAS_HERE_reversed_0 = coredsl.bitextract "
                          + "%TREENAIL_WAS_HERE_Imm6_5_0[0:5] : (ui6) -> ui6"),
        "app should be able to emit bit reversal code");
    assertTrue(
        mlirCode.contains(
            "%Imm6 = coredsl.cast %TREENAIL_WAS_HERE_reversed_0 : ui6 to ui6"),
        "app should be able to retain the original reversed encoding field "
            + "name");

    assertTrue(
        mlirCode.contains("%TREENAIL_WAS_HERE_reversed_1 = coredsl.bitextract "
                          + "%TREENAIL_WAS_HERE_rs1_2_0[0:2] : (ui3) -> ui3"),
        "app should be able to emit bit reversal code");
    assertTrue(mlirCode.contains("%TREENAIL_WAS_HERE_2 = coredsl.concat "
                                 + "%TREENAIL_WAS_HERE_rs1_4_3, "
                                 + "%TREENAIL_WAS_HERE_reversed_1 : ui2, ui3"),
               "app should be able to concat split and reversed bitfields");
    assertTrue(mlirCode.contains(
                   "%rs1 = coredsl.cast %TREENAIL_WAS_HERE_2 : ui5 to ui5"),
               "app should be able to retain the original split and reversed "
                   + "encoding field name");
  }

  @Test
  void constVolatileWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("const_volatile.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(mlirCode, "MLIR should be output without errors");
    // Test register files with qualifiers
    assertTrue(mlirCode.contains("coredsl.register core_x @X[32] : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local const @CONST_REG_FILE[10] : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local volatile @VOLATILE_REG_FILE[12] : ui32"));
    assertTrue(mlirCode.contains("coredsl.register local const volatile "
                                 + "@CONST_VOLATILE_REG_FILE[14] : ui32"));
    // test scalar registers with qualifiers
    assertTrue(
        mlirCode.contains("coredsl.register local @NORMAL_REG = 5 : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local const @CONST_REG = 10 : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local volatile @VOLATILE_REG = 12 : ui32"));
    assertTrue(mlirCode.contains("coredsl.register local const volatile "
                                 + "@CONST_VOLATILE_REG = 42 : ui32"));
    // Make sure output MLIR contains address space command with qualifiers
    assertTrue(
        mlirCode.contains("coredsl.addrspace core_mem @MEM : (ui32) -> ui8"));
    assertTrue(mlirCode.contains(
        "coredsl.addrspace core_mem const @CONST_MEM : (ui64) -> ui8"));
    assertTrue(mlirCode.contains(
        "coredsl.addrspace core_mem volatile @VOLATILE_MEM : (ui8) -> ui8"));
    assertTrue(mlirCode.contains("coredsl.addrspace core_mem const volatile "
                                 + "@CONST_VOLATILE_MEM : (ui16) -> ui8"));

    assertTrue(mlirCode.contains("coredsl.alias @FIRST_MEM_VAL = @MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias const @FIRST_CONST_MEM_VAL = @CONST_MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias volatile @FIRST_VOLATILE_MEM_VAL = @VOLATILE_MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias const volatile @FIRST_CONST_VOLATILE_MEM_VAL = "
        + "@CONST_VOLATILE_MEM[0]"));
  }

  @Test
  void multipleDeclaratorsWork() {
    var appInst = App.getInstance();
    // NOTE: This file is parsed and converted to mlir in other tests
    var expectedFileName =
        getClass().getResource("intro_syntax.core_desc").getPath();
    var expectedContent = appInst.parse(expectedFileName);
    assertNotNull(expectedContent,
                  "app should be able to parse a simple CoreDSL file");
    var expectedMlir = appInst.generateMLIR(expectedContent);
    assertNotNull(expectedMlir);

    var testFileName =
        getClass()
            .getResource("intro_syntax_multiple_declarators.core_desc")
            .getPath();
    var testContent = appInst.parse(testFileName);
    assertNotNull(testContent);
    var gotMlir = appInst.generateMLIR(testContent);
    assertNotNull(gotMlir);

    assertEquals(gotMlir, expectedMlir);
  }

  @Test
  void shortCircuitEvaluationWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("short_circuit.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(mlirCode);
    // clang-format off
    // LogicalAndTest
    assertTrue(mlirCode.contains("""
          %7 = coredsl.cast %4 : ui1 to i1
          %6 = scf.if %7 -> (ui1) {
            %8 = hwarith.constant 10 : ui4
            %10 = hwarith.icmp lt %2, %8 : ui32, ui4
            %9 = hwarith.cast %10 : (i1) -> ui1
            scf.yield %9 : ui1
          } else {
            %8 = hwarith.constant 0 : ui1
            scf.yield %8 : ui1
          }
      """));
    // LogicalOrTest
    assertTrue(mlirCode.contains("""
          %7 = coredsl.cast %4 : ui1 to i1
          %6 = scf.if %7 -> (ui1) {
            %8 = hwarith.constant 1 : ui1
            scf.yield %8 : ui1
          } else {
            %8 = hwarith.constant 10 : ui4
            %10 = hwarith.icmp gt %2, %8 : ui32, ui4
            %9 = hwarith.cast %10 : (i1) -> ui1
            scf.yield %9 : ui1
          }
      """));
    // ConvertToBoolTest
    assertTrue(mlirCode.contains("""
          %4 = hwarith.constant 0 : ui32
          %5 = hwarith.icmp ne %0 %4
          %6 = coredsl.cast %5 : ui1 to i1
          %3 = scf.if %6 -> (ui1) {
            %7 = hwarith.constant 1 : ui1
            scf.yield %7 : ui1
          } else {
            %7 = hwarith.constant 0 : ui32
            %8 = hwarith.icmp ne %2 %7
            scf.yield %8 : ui1
          }
      """));
    // MultipleShortCircuitTest
    assertTrue(mlirCode.contains("""
          %7 = coredsl.cast %4 : ui1 to i1
          %6 = scf.if %7 -> (ui1) {
            %8 = hwarith.constant 10 : ui4
            %10 = hwarith.icmp lt %0, %8 : ui32, ui4
            %9 = hwarith.cast %10 : (i1) -> ui1
            scf.yield %9 : ui1
          } else {
            %8 = hwarith.constant 0 : ui1
            scf.yield %8 : ui1
          }
          %9 = coredsl.cast %6 : ui1 to i1
          %8 = scf.if %9 -> (ui1) {
            %10 = hwarith.constant 1 : ui1
            scf.yield %10 : ui1
          } else {
            %10 = hwarith.constant 10 : ui4
            %12 = hwarith.icmp gt %2, %10 : ui32, ui4
            %11 = hwarith.cast %12 : (i1) -> ui1
            %14 = coredsl.cast %11 : ui1 to i1
            %13 = scf.if %14 -> (ui1) {
              %15 = hwarith.constant 15 : ui4
              %17 = hwarith.icmp lt %2, %15 : ui32, ui4
              %16 = hwarith.cast %17 : (i1) -> ui1
              scf.yield %16 : ui1
            } else {
              %15 = hwarith.constant 0 : ui1
              scf.yield %15 : ui1
            }
            %16 = coredsl.cast %13 : ui1 to i1
            %15 = scf.if %16 -> (ui1) {
              %17 = hwarith.constant 1 : ui1
              scf.yield %17 : ui1
            } else {
              %17 = hwarith.constant 0 : ui1
              %19 = hwarith.icmp eq %2, %17 : ui32, ui1
              %18 = hwarith.cast %19 : (i1) -> ui1
              scf.yield %18 : ui1
            }
            scf.yield %15 : ui1
          }
      """));
    // LoopShortCircuitWithSideEffect
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 0 : ui32
          %1 = hwarith.constant 0 : ui1
          %2 = coredsl.cast %1 : ui1 to ui32
          %3 = scf.while (%3 = %2) : (ui32) -> (ui32) {
            %4 = hwarith.constant 10 : ui4
            %6 = hwarith.icmp lt %3, %4 : ui32, ui4
            %5 = hwarith.cast %6 : (i1) -> ui1
            %8 = coredsl.cast %5 : ui1 to i1
            %7 = scf.if %8 -> (ui1) {
              %9 = coredsl.get @X[1] : ui32
              %10 = hwarith.constant 1 : ui1
              %11 = hwarith.add %9, %10 : (ui32, ui1) -> ui33
              %12 = coredsl.cast %11 : ui33 to ui32
              coredsl.set @X[1] = %12 : ui32
              %13 = hwarith.constant 10 : ui4
              %15 = hwarith.icmp lt %9, %13 : ui32, ui4
              %14 = hwarith.cast %15 : (i1) -> ui1
              scf.yield %14 : ui1
            } else {
              %9 = hwarith.constant 0 : ui1
              scf.yield %9 : ui1
            }
            %9 = coredsl.cast %7 : ui1 to i1
            scf.condition(%9) %3 : ui32
          } do {
          ^bb0(%3: ui32):
            %4 = hwarith.constant 2 : ui2
            %5 = coredsl.get @X[1] : ui32
            %6 = hwarith.add %5, %4 : (ui32, ui2) -> ui33
            %7 = coredsl.cast %6 : ui33 to ui32
            coredsl.set @X[1] = %7 : ui32
            %8 = hwarith.constant 1 : ui1
            %9 = hwarith.add %3, %8 : (ui32, ui1) -> ui33
            %10 = coredsl.cast %9 : ui33 to ui32
            scf.yield %10 : ui32
          }
          coredsl.set @X[2] = %3 : ui32
      """));
    // clang-format on
  }

  @Test
  void nestedLValuesTest() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("nested_lvalues.core_desc").getPath();
    var content = appInst.parse(fileName);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(mlirCode);
    // clang-format off
    // SimpleRegStore
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 43 : ui6
          %1 = coredsl.cast %0 : ui6 to ui32
          coredsl.set @X[%rs2 : ui5] = %1 : ui32
      """));
    // SimpleBitAccessStore
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 3 : ui2
          %1 = coredsl.get @PC : ui32
          %2 = coredsl.cast %0 : ui2 to ui5
          %3 = coredsl.bitset %1[4:0] = %2 : (ui32, ui5) -> ui32
          coredsl.set @PC = %3 : ui32
      """));
    // SimpleRangedAddressSpaceStore
    assertTrue(mlirCode.contains("""
          %0 = coredsl.get @MEM[8:4] : ui40
          coredsl.set @MEM[4:0] = %0 : ui40
      """));
    // RegScalarThenBitAccessStore
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 100 : ui7
          %1 = coredsl.get @X[%rs2 : ui5] : ui32
          %2 = coredsl.cast %0 : ui7 to ui11
          %3 = coredsl.bitset %1[0:10] = %2 : (ui32, ui11) -> ui32
          coredsl.set @X[%rs2 : ui5] = %3 : ui32
      """));
    // MemScalarThenBitAccessStore
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 8 : ui4
          %1 = coredsl.cast %rs2 : ui5 to ui32
          %2 = coredsl.get @MEM[%1 : ui32] : ui8
          %3 = coredsl.cast %0 : ui4 to ui5
          %4 = coredsl.bitset %2[0:4] = %3 : (ui8, ui5) -> ui8
          coredsl.set @MEM[%1 : ui32] = %4 : ui8
      """));
    // NestedBitAccess
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 42 : ui6
          %1 = coredsl.get @PC : ui32
          %2 = coredsl.bitextract %1[16:0] : (ui32) -> ui17
          %3 = coredsl.cast %0 : ui6 to ui9
          %4 = coredsl.bitset %2[8:0] = %3 : (ui17, ui9) -> ui17
          %5 = coredsl.bitset %1[16:0] = %4 : (ui32, ui17) -> ui32
          coredsl.set @PC = %5 : ui32
      """));
    // TripleNestedBitAccess
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 42 : ui6
          %1 = coredsl.get @PC : ui32
          %2 = coredsl.bitextract %1[31:0] : (ui32) -> ui32
          %3 = coredsl.bitextract %2[15:0] : (ui32) -> ui16
          %4 = coredsl.cast %0 : ui6 to ui8
          %5 = coredsl.bitset %3[7:0] = %4 : (ui16, ui8) -> ui16
          %6 = coredsl.bitset %2[15:0] = %5 : (ui32, ui16) -> ui32
          %7 = coredsl.bitset %1[31:0] = %6 : (ui32, ui32) -> ui32
          coredsl.set @PC = %7 : ui32
      """));
    // ScalarThenTwoBitAccesses
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 3 : ui2
          %1 = coredsl.cast %rs2 : ui5 to ui32
          %2 = coredsl.get @MEM[%1 : ui32] : ui8
          %3 = coredsl.bitextract %2[4:0] : (ui8) -> ui5
          %4 = coredsl.cast %0 : ui2 to ui3
          %5 = coredsl.bitset %3[2:0] = %4 : (ui5, ui3) -> ui5
          %6 = coredsl.bitset %2[4:0] = %5 : (ui8, ui5) -> ui8
          coredsl.set @MEM[%1 : ui32] = %6 : ui8
      """));
    // LocalNestedBitAccess
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 10 : ui4
          %1 = coredsl.cast %0 : ui4 to ui32
          %2 = hwarith.constant 3 : ui2
          %3 = coredsl.bitextract %1[15:0] : (ui32) -> ui16
          %4 = coredsl.cast %2 : ui2 to ui8
          %5 = coredsl.bitset %3[7:0] = %4 : (ui16, ui8) -> ui16
          %6 = coredsl.bitset %1[15:0] = %5 : (ui32, ui16) -> ui32
          coredsl.set @X[1] = %6 : ui32
      """));
    // LocalTripleNestedBitAccess
    assertTrue(mlirCode.contains("""
          %0 = hwarith.constant 10 : ui4
          %1 = coredsl.cast %0 : ui4 to ui32
          %2 = hwarith.constant 3 : ui2
          %3 = coredsl.bitextract %1[15:0] : (ui32) -> ui16
          %4 = coredsl.bitextract %3[7:0] : (ui16) -> ui8
          %5 = coredsl.cast %2 : ui2 to ui5
          %6 = coredsl.bitset %4[4:0] = %5 : (ui8, ui5) -> ui8
          %7 = coredsl.bitset %3[7:0] = %6 : (ui16, ui8) -> ui16
          %8 = coredsl.bitset %1[15:0] = %7 : (ui32, ui16) -> ui32
          coredsl.set @X[1] = %8 : ui32
      """));
    // clang-format on
  }

  @Test
  void architecturalStateInRangeSpecWorks() {
    var appInst = App.getInstance();
    var fileName =
        getClass()
            .getResource("architectural_state_in_range_spec.core_desc")
            .getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(mlirCode);
    // clang-format off
    // TestArchStateIsFrom
    assertTrue(mlirCode.contains("""
          %1 = coredsl.get @TEST_REG : ui32
          %0 = coredsl.get @MEM[%1 : ui32, 0:1] : ui16
          %2 = coredsl.cast %0 : ui16 to ui32
          coredsl.set @X[0] = %2 : ui32
      """));
    // TestArchStateIsTo
    assertTrue(mlirCode.contains("""
          %1 = coredsl.get @TEST_REG : ui32
          %0 = coredsl.get @MEM[%1 : ui32, -1:0] : ui16
          %2 = coredsl.cast %0 : ui16 to ui32
          coredsl.set @X[0] = %2 : ui32
      """));
    // TestArchStateIsFromIndexCast
    assertTrue(mlirCode.contains("""
          %1 = coredsl.get @TEST_REG_64 : ui64
          %2 = coredsl.cast %1 : ui64 to ui32
          %0 = coredsl.get @MEM[%2 : ui32, 0:1] : ui16
          %3 = coredsl.cast %0 : ui16 to ui32
          coredsl.set @X[0] = %3 : ui32
      """));
    // TestArchStateIsToIndexCast
    assertTrue(mlirCode.contains("""
          %1 = coredsl.get @TEST_REG_64 : ui64
          %2 = coredsl.cast %1 : ui64 to ui32
          %0 = coredsl.get @MEM[%2 : ui32, -1:0] : ui16
          %3 = coredsl.cast %0 : ui16 to ui32
          coredsl.set @X[0] = %3 : ui32
      """));
    // clang-format on
  }

  @Test
  void conditionalExprWithSideEffectsWorks() {
    var appInst = App.getInstance();
    var fileName = getClass()
                       .getResource("conditional_expr_side_effects.core_desc")
                       .getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(mlirCode);
    // clang-format off
    // TestModificationInThen
    assertTrue(mlirCode.contains("""
          %0 = coredsl.get @MEM[4:1] : ui32
          %1 = coredsl.get @X[0] : ui32
          %2 = hwarith.constant 645 : ui10
          %4 = hwarith.icmp eq %1, %2 : ui32, ui10
          %3 = hwarith.cast %4 : (i1) -> ui1
          %5 = coredsl.cast %3 : ui1 to i1
          %6, %7 = scf.if %5 -> (ui32, ui16) {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.add %0, %6 : (ui32, ui1) -> ui33
            %8 = coredsl.cast %7 : ui33 to ui32
            %9 = hwarith.constant 1 : ui1
            %10 = hwarith.sub %0, %9 : (ui32, ui1) -> si33
            %11 = coredsl.cast %10 : si33 to ui16
            scf.yield %8, %11 : ui32, ui16
          } else {
            %6 = hwarith.constant 2 : ui2
            %7 = hwarith.mul %0, %6 : (ui32, ui2) -> ui34
            %8 = coredsl.cast %7 : ui34 to ui16
            scf.yield %0, %8 : ui32, ui16
          }
          coredsl.set @X[0] = %6 : ui32
          %8 = coredsl.cast %7 : ui16 to ui32
          coredsl.set @X[1] = %8 : ui32
      """));
    // TestModificationInElse
    assertTrue(mlirCode.contains("""
          %0 = coredsl.get @MEM[3:2] : ui16
          %1 = coredsl.get @X[0] : ui32
          %2 = hwarith.constant 645 : ui10
          %4 = hwarith.icmp eq %1, %2 : ui32, ui10
          %3 = hwarith.cast %4 : (i1) -> ui1
          %5 = coredsl.cast %3 : ui1 to i1
          %6, %7 = scf.if %5 -> (ui16, ui32) {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.sub %0, %6 : (ui16, ui1) -> si17
            %8 = coredsl.cast %7 : si17 to ui32
            scf.yield %0, %8 : ui16, ui32
          } else {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.add %0, %6 : (ui16, ui1) -> ui17
            %8 = coredsl.cast %7 : ui17 to ui16
            %9 = hwarith.constant 2 : ui2
            %10 = hwarith.mul %8, %9 : (ui16, ui2) -> ui18
            %11 = coredsl.cast %10 : ui18 to ui32
            scf.yield %8, %11 : ui16, ui32
          }
          %8 = coredsl.cast %6 : ui16 to ui32
          coredsl.set @X[0] = %8 : ui32
          coredsl.set @X[1] = %7 : ui32
      """));
    // TestModificationInThenAndIf
    assertTrue(mlirCode.contains("""
          %0 = coredsl.get @MEM[1:0] : ui16
          %1 = coredsl.get @X[0] : ui32
          %2 = hwarith.constant 645 : ui10
          %4 = hwarith.icmp eq %1, %2 : ui32, ui10
          %3 = hwarith.cast %4 : (i1) -> ui1
          %5 = coredsl.cast %3 : ui1 to i1
          %6, %7 = scf.if %5 -> (ui16, ui16) {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.sub %0, %6 : (ui16, ui1) -> si17
            %8 = coredsl.cast %7 : si17 to ui16
            %9 = hwarith.constant 1 : ui1
            %10 = hwarith.sub %8, %9 : (ui16, ui1) -> si17
            %11 = coredsl.cast %10 : si17 to ui16
            scf.yield %8, %11 : ui16, ui16
          } else {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.add %0, %6 : (ui16, ui1) -> ui17
            %8 = coredsl.cast %7 : ui17 to ui16
            %9 = hwarith.constant 2 : ui2
            %10 = hwarith.mul %8, %9 : (ui16, ui2) -> ui18
            %11 = coredsl.cast %10 : ui18 to ui16
            scf.yield %8, %11 : ui16, ui16
          }
          %8 = coredsl.cast %6 : ui16 to ui32
          coredsl.set @X[0] = %8 : ui32
          %9 = coredsl.cast %7 : ui16 to ui32
          coredsl.set @X[1] = %9 : ui32
      """));
    // TestMultipleModifiedVariables
    assertTrue(mlirCode.contains("""
          %0 = coredsl.get @MEM[1:0] : ui16
          %1 = coredsl.get @X[0] : ui32
          %2 = coredsl.get @X[0] : ui32
          %3 = hwarith.constant 645 : ui10
          %5 = hwarith.icmp eq %2, %3 : ui32, ui10
          %4 = hwarith.cast %5 : (i1) -> ui1
          %6 = coredsl.cast %4 : ui1 to i1
          %7, %8, %9 = scf.if %6 -> (ui16, ui32, ui64) {
            %7 = hwarith.constant 1 : ui1
            %8 = hwarith.sub %0, %7 : (ui16, ui1) -> si17
            %9 = coredsl.cast %8 : si17 to ui16
            %10 = hwarith.constant 1 : ui1
            %11 = hwarith.sub %9, %10 : (ui16, ui1) -> si17
            %12 = coredsl.cast %11 : si17 to ui64
            scf.yield %9, %1, %12 : ui16, ui32, ui64
          } else {
            %7 = hwarith.constant 1 : ui1
            %8 = hwarith.add %0, %7 : (ui16, ui1) -> ui17
            %9 = coredsl.cast %8 : ui17 to ui16
            %10 = hwarith.constant 10 : ui4
            %11 = coredsl.cast %10 : ui4 to ui32
            %12 = hwarith.mul %9, %11 : (ui16, ui32) -> ui48
            %13 = coredsl.cast %12 : ui48 to ui64
            scf.yield %9, %11, %13 : ui16, ui32, ui64
          }
          %10 = coredsl.cast %7 : ui16 to ui32
          coredsl.set @X[0] = %10 : ui32
          coredsl.set @X[1] = %8 : ui32
          %11 = coredsl.bitextract %9[31:0] : (ui64) -> ui32
          coredsl.set @X[2] = %11 : ui32
          %12 = coredsl.bitextract %9[63:32] : (ui64) -> ui32
          coredsl.set @X[3] = %12 : ui32
      """));
    // TestModifyingArchState
    assertTrue(mlirCode.contains("""
          %rs1 = coredsl.cast %TREENAIL_WAS_HERE_2 : ui5 to ui5
          %rd = coredsl.cast %TREENAIL_WAS_HERE_rd_4_0 : ui5 to ui5
          %0 = coredsl.get @MEM[4:1] : ui32
          %1 = coredsl.get @X[0] : ui32
          %2 = hwarith.constant 645 : ui10
          %4 = hwarith.icmp eq %1, %2 : ui32, ui10
          %3 = hwarith.cast %4 : (i1) -> ui1
          %5 = coredsl.cast %3 : ui1 to i1
          %6, %7 = scf.if %5 -> (ui32, ui16) {
            %6 = hwarith.constant 1 : ui1
            %7 = hwarith.add %0, %6 : (ui32, ui1) -> ui33
            %8 = coredsl.cast %7 : ui33 to ui32
            %9 = hwarith.constant 1 : ui1
            %10 = hwarith.sub %0, %9 : (ui32, ui1) -> si33
            %11 = coredsl.cast %10 : si33 to ui16
            scf.yield %8, %11 : ui32, ui16
          } else {
            %6 = coredsl.get @SINGLE_REG : ui32
            %7 = hwarith.constant 1 : ui1
            %8 = hwarith.add %6, %7 : (ui32, ui1) -> ui33
            %9 = coredsl.cast %8 : ui33 to ui32
            coredsl.set @SINGLE_REG = %9 : ui32
            %10 = hwarith.constant 2 : ui2
            %11 = hwarith.mul %6, %10 : (ui32, ui2) -> ui34
            %12 = coredsl.cast %11 : ui34 to ui16
            scf.yield %0, %12 : ui32, ui16
          }
          coredsl.set @X[0] = %6 : ui32
          %8 = coredsl.cast %7 : ui16 to ui32
          coredsl.set @X[1] = %8 : ui32
      """));
    // clang-format on
  }
}
