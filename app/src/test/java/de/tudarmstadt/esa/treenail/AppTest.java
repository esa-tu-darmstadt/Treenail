/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.tudarmstadt.esa.treenail;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class AppTest {
  @Test
  void parserWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("intro_syntax.core_desc").getPath();
    assertNotNull(appInst.parse(fileName),
                  "app should be able to parse a simple CoreDSL file");
  }

  @Test
  void codegenWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("test1.core_desc").getPath();
    var content = appInst.parse(fileName);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(appInst.generateMLIR(content).startsWith("lil.isax \"Test1\""),
               "app should be able to generate MLIR");
  }

  @Test
  void splitEncodingFieldWorks() {
    var appInst = App.getInstance();
    var fileName =
        getClass().getResource("split_enc_field.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(mlirCode.startsWith("lil.isax \"TestSplitEncFields\""),
               "app should be able to generate MLIR");
    assertTrue(mlirCode.contains("%TREENAIL_WAS_HERE_0 = coredsl.concat "
                                 + "%TREENAIL_WAS_HERE_Imm6_5_1, "
                                 + "%TREENAIL_WAS_HERE_Imm6_0_0 : ui5, ui1"),
               "app should be able to merge split encoding fields");
    assertTrue(
        mlirCode.contains(
            "%Imm6 = coredsl.cast %TREENAIL_WAS_HERE_0 : ui6 to ui6"),
        "app should be able to retain the original split encoding field name");
  }

  @Test
  void reversedEncodingFieldWorks() {
    var appInst = App.getInstance();
    var fileName =
        getClass().getResource("reversed_enc_field.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    assertNotNull(content, "app should be able to parse a simple CoreDSL file");
    assertTrue(mlirCode.startsWith("lil.isax \"TestReversedEncFields\""),
               "app should be able to generate MLIR");
    assertTrue(
        mlirCode.contains("%TREENAIL_WAS_HERE_reversed_0 = coredsl.bitextract "
                          + "%TREENAIL_WAS_HERE_Imm6_5_0[0:5] : (ui6) -> ui6"),
        "app should be able to emit bit reversal code");
    assertTrue(
        mlirCode.contains(
            "%Imm6 = coredsl.cast %TREENAIL_WAS_HERE_reversed_0 : ui6 to ui6"),
        "app should be able to retain the original reversed encoding field "
            + "name");

    assertTrue(
        mlirCode.contains("%TREENAIL_WAS_HERE_reversed_1 = coredsl.bitextract "
                          + "%TREENAIL_WAS_HERE_rs1_2_0[0:2] : (ui3) -> ui3"),
        "app should be able to emit bit reversal code");
    assertTrue(mlirCode.contains("%TREENAIL_WAS_HERE_2 = coredsl.concat "
                                 + "%TREENAIL_WAS_HERE_rs1_4_3, "
                                 + "%TREENAIL_WAS_HERE_reversed_1 : ui2, ui3"),
               "app should be able to concat split and reversed bitfields");
    assertTrue(mlirCode.contains(
                   "%rs1 = coredsl.cast %TREENAIL_WAS_HERE_2 : ui5 to ui5"),
               "app should be able to retain the original split and reversed "
                   + "encoding field name");
  }

  @Test
  void constVolatileWorks() {
    var appInst = App.getInstance();
    var fileName = getClass().getResource("const_volatile.core_desc").getPath();
    var content = appInst.parse(fileName);
    var mlirCode = appInst.generateMLIR(content);
    System.out.println(mlirCode);
    assertNotNull(mlirCode, "MLIR should be output without errors");
    // Test register files with qualifiers
    assertTrue(mlirCode.contains("coredsl.register core_x @X[32] : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local const @CONST_REG_FILE[10] : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local volatile @VOLATILE_REG_FILE[12] : ui32"));
    assertTrue(mlirCode.contains("coredsl.register local const volatile "
                                 + "@CONST_VOLATILE_REG_FILE[14] : ui32"));
    // test scalar registers with qualifiers
    assertTrue(
        mlirCode.contains("coredsl.register local @NORMAL_REG = 5 : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local const @CONST_REG = 10 : ui32"));
    assertTrue(mlirCode.contains(
        "coredsl.register local volatile @VOLATILE_REG = 12 : ui32"));
    assertTrue(mlirCode.contains("coredsl.register local const volatile "
                                 + "@CONST_VOLATILE_REG = 42 : ui32"));
    // Make sure output MLIR contains address space command with qualifiers
    assertTrue(
        mlirCode.contains("coredsl.addrspace core_mem @MEM : (ui32) -> ui8"));
    assertTrue(mlirCode.contains(
        "coredsl.addrspace core_mem const @CONST_MEM : (ui64) -> ui8"));
    assertTrue(mlirCode.contains(
        "coredsl.addrspace core_mem volatile @VOLATILE_MEM : (ui8) -> ui8"));
    assertTrue(mlirCode.contains("coredsl.addrspace core_mem const volatile "
                                 + "@CONST_VOLATILE_MEM : (ui16) -> ui8"));

    assertTrue(mlirCode.contains("coredsl.alias @FIRST_MEM_VAL = @MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias const @FIRST_CONST_MEM_VAL = @CONST_MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias volatile @FIRST_VOLATILE_MEM_VAL = @VOLATILE_MEM[0]"));
    assertTrue(mlirCode.contains(
        "coredsl.alias const volatile @FIRST_CONST_VOLATILE_MEM_VAL = "
        + "@CONST_VOLATILE_MEM[0]"));
  }
}
